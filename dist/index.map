{"version":3,"sources":["index.js"],"names":["global","factory","exports","module","define","amd","formatNumString","numString","eIndex","indexOf","pureNumString","slice","power","parseInt","noDotString","replace","resString","repeat","multiply","num1","num2","splitNumber","num1Arr","num2Arr","len1","len2","multiplyTempNum","num1Integer","num1Dot","isNegative","num2Integer","num2Dot","num2IntegerMultiplied","res","divide","multipliedNum1","add","toString","split","length","maxLen","Math","max","num","sg_calc","minus","result","start","createTempCalc","self","num3","num4","end"],"mappings":"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","file":"index.map","sourceRoot":"../src","sourcesContent":[";(function (global, factory) {\n\ttypeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :\n\t\ttypeof define === 'function' && define.amd ? define(factory) : global['sg_calc'] = factory()\n})(this, function () {\n\t// 规范小数科学计数法带来的影响\n\tfunction formatNumString(numString) {\n\t\tlet eIndex = numString.indexOf('e')\n\n\t\tif (eIndex > -1 && numString.indexOf('-') > 0) {\n\t\t\tlet pureNumString = numString.slice(0, eIndex)\n\t\t\tlet power = parseInt(numString.slice(eIndex + 2))\n\t\t\tlet noDotString = pureNumString.replace('.', '')\n\t\t\tlet zeroString = '0.' + '0'.repeat(power - 1)\n\t\t\tlet resString = zeroString + noDotString\n\n\t\t\treturn resString\n\t\t}\n\n\t\treturn numString\n\t}\n\n\t// 乘法\n\tfunction multiply(num1, num2) {\n\t\tconst { num1Arr, num2Arr, len1, len2, multiplyTempNum } = splitNumber(num1, num2)\n\n\t\tconst num1Integer = parseInt(num1Arr[0]) // num1整数部分\n\t\tconst num1Dot = isNegative(num1) ? parseInt(-num1Arr[1] || -0) : parseInt(num1Arr[1] || 0) // num1小数部分\n\t\tconst num2Integer = parseInt(num2Arr[0]) // num2整数部分\n\t\tconst num2Dot = isNegative(num2) ? parseInt(-num2Arr[1] || -0) : parseInt(num2Arr[1] || 0) // num2小数部分\n\n\t\t// 整数小数部分分别乘以multiplyTempNum\n\t\tconst num1IntegerMultiplied= num1Integer * multiplyTempNum\n\t\tconst num2IntegerMultiplied= num2Integer * multiplyTempNum\n\t\tconst num1DotMultiplied= num1Dot * (multiplyTempNum / 10 ** len1)\n\t\tconst num2DotMultiplied= num2Dot * (multiplyTempNum / 10 ** len2)\n\n\t\t// 把相乘之后的结果整数小数部分相加\n\t\tconst bigNum1 = num1IntegerMultiplied+ num1DotMultiplied\n\t\tconst bigNum2 = num2IntegerMultiplied+ num2DotMultiplied\n\n\t\tconst multipliedRes = bigNum1 * bigNum2\n\t\tconst res = multipliedRes / (multiplyTempNum ** 2)\n\n\t\treturn res\n\t}\n\n\t// 除法\n\tfunction divide(num1, num2) {\n\t\tconst { multiplyTempNum } = splitNumber(num1, num2)\n\n\t\tconst multipliedNum1 = multiply(num1, multiplyTempNum)\n\t\tconst multipliedNum2 = multiply(num2, multiplyTempNum)\n\n\t\treturn multipliedNum1 / multipliedNum2\n\t}\n\n\t// 加法\n\tfunction add(num1, num2) {\n\t\tconst { multiplyTempNum } = splitNumber(num1, num2)\n\n\t\tconst multipliedNum1 = multiply(num1, multiplyTempNum)\n\t\tconst multipliedNum2 = multiply(num2, multiplyTempNum)\n\n\t\treturn \tdivide(multipliedNum1 + multipliedNum2, multiplyTempNum)\n\t}\n\n\t// 减法\n\tfunction minus(num1, num2) {\n\t\treturn add(num1, -num2)\n\t}\n\n\t// 拆分数字\n\tfunction splitNumber(num1, num2) {\n\t\tconst num1Arr = formatNumString(num1.toString()).split('.')\n\t\tconst num2Arr = formatNumString(num2.toString()).split('.')\n\t\tconst len1 = num1Arr[1] ? num1Arr[1].length : 0\n\t\tconst len2 = num2Arr[1] ? num2Arr[1].length : 0\n\t\tconst maxLen = Math.max(len1, len2)\n\t\tconst multiplyTempNum = 10 ** maxLen\n\n\t\treturn { num1Arr, num2Arr, len1, len2, multiplyTempNum }\n\t}\n\n\t// 判断是否是负数\n\tfunction isNegative(num) {\n\t\treturn num.toString().indexOf('-') === 0\n\t}\n\n\tconst sg_calc = {\n\t\tadd: add,\n\t\tminus: minus,\n\t\tmultiply: multiply,\n\t\tdivide: divide,\n\t\tresult: 0,\n\t\tstart (num) {\n\t\t\tlet self = this\n\n\t\t\treturn createTempCalc(self, num)\n\t\t},\n\t\tend () {\n\t\t\treturn this.result\n\t\t}\n\t}\n\n\t// 创建临时计算的函数\n\tfunction createTempCalc (self, num) {\n\t\treturn {\n\t\t\tadd (num1) {\n\t\t\t\tlet res = sg_calc.add(num, num1)\n\t\t\t\tself.result = res\n\n\t\t\t\treturn createTempCalc(self, res)\n\t\t\t},\n\t\t\tminus (num2) {\n\t\t\t\tlet res = sg_calc.minus(num, num2)\n\t\t\t\tself.result = res\n\n\t\t\t\treturn createTempCalc(self, res)\n\t\t\t},\n\t\t\tmultiply (num3) {\n\t\t\t\tlet res = sg_calc.multiply(num, num3)\n\t\t\t\tself.result = res\n\n\t\t\t\treturn createTempCalc(self, res)\n\t\t\t},\n\t\t\tdivide (num4) {\n\t\t\t\tlet res = sg_calc.divide(num, num4)\n\t\t\t\tself.result = res\n\n\t\t\t\treturn createTempCalc(self, res)\n\t\t\t},\n\t\t\tend () {\n\t\t\t\treturn self.end()\n\t\t\t}\n\t\t}\n\t}\n\n\t// function test() {\n\t// \tassert.equal(calc.start(0.1).add(0.2).end(), 0.3, '测试1')\n\t// \tassert.equal(calc.start(0.1).add(0.2).multiply(3).end(), 0.9, '测试2')\n\t// \tassert.equal(calc.start(0.3).minus(3).end(), -2.7, '测试3')\n\t// \tassert.equal(calc.start(0.2).multiply(0.4).add(1).end(), 1.08, '测试4')\n\t// }\n\n\treturn sg_calc\n});"]}